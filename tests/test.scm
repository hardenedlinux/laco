(define-module (tests test)
  #:use-module (srfi srfi-64)
  #:use-module (rnrs)
  #:use-module (laco compile))

(define (animula-run name)
  (let ((tf (format #f "tests/scm/~a.scm" name)))
    (when (not (file-exists? tf))
      (format #t "The test file `~a' is missing!" tf)
      (exit -1))
    (let ((vm (getenv "ANIMULA_VM_PATH"))
          (lef (format #f "/tmp/~a.lef" name)))
      (when (not vm)
        (format #t "Please set ANIMULA_VM_PATH then try again!")
        (exit -2))
      (system (format #f "./pre-inst-env scripts/laco ~a -o ~a >/dev/null" tf lef))
      (system (format #f "~a/animula-vm ~a > /tmp/~a.log" vm lef name))
      (call-with-input-file (format #f "/tmp/~a.log" name) get-string-all))))

(define (get-result name)
  (call-with-input-file (format #f "tests/result/~a.txt" name) get-string-all))

(define (check case-name name)
  (when (string=? name "numbers")
    (test-expect-fail 2))
  (test-group case-name
              (test-equal name
                          (get-result name)
                          (animula-run name))))

(check "Rational 1" "rational-1")
(check "Fibonacci Sequence" "fibonacci")
(check "Factorial" "factorial")
(check "Nested calling" "nested-call")
(check "Simple sequence printing" "simple-seq-print")
(check "GCD" "gcd")
(check "Symbol list" "symbol-list")
(check "Integer list" "int-list")
(check "Variables in list" "var-list")
(check "List print" "list-print")
(check "Fold branch 1" "fold-branch-1")
(check "Fold branch 2" "fold-branch-2")
(check "Branch 1" "branch-1")
(check "Branch 2" "branch-2")
(check "define* keys" "define-star-keys")
(check "define* optionals" "define-star-opts")
(check "define* keys and -opts" "define-star-keys-opts")
(check "Constant keyword printing" "keyword-print")
(check "let test 1" "let-1")
(check "let* test 1" "let-star-1")
(check "let* test 2" "let-star-optimized-out")
(check "let* test 3" "let-star-side-effect-1")
(check "list append" "list-append")
(check "list car cdr" "list-car-cdr")
(check "char print" "char-print")
(check "list->string" "list_to_string")
(check "Lambda Lifting 1" "lambda-lifting-1")
(check "Lambda Lifting 2" "lambda-lifting-2")
(check "Lambda multi-args application" "lambda-app-multi-args")
(check "Closure 1" "closure-1")
(check "Closure 2" "closure-2")
(check "Global expression 1" "global-expr-1")
(check "Named Let 1" "named-let-1")
(check "Named Let 2" "named-let-2")
(check "Named Let 3" "named-let-3")
(check "Named Let Loop" "named-let-loop")
(check "Named Let Loop in Function" "named-let-loop-in-func")
(check "Applicative order 1" "applicative-order-1")
(check "list-ref" "list-ref")
(check "add_sub" "add_sub")
(check "multiply" "multiply")
(check "macro-simple" "macro-simple")
(check "macro-quasi-simple" "macro-quasi-simple")
(check "Rational Division" "rational-division")
(check "pair" "pair")
(check "null" "null")
(check "Nested Lambda 1" "nested-lambda-1")
(check "eq_gt_lt" "eq_gt_lt")
(check "Global List 1" "global-list-1")
(check "Exprs in the mid of definition" "expr-in-mid-defs")
(check "Raise" "raise")
(check "Raise continuable" "raise-cont")
(check "Re-define toplevel" "redefine")
(check "Bytevector Operations" "bytevector")
(check "And test" "and-test")
(check "Or test" "or-test")
(check "quasi-simple" "quasi-simple")
(check "Mathematical Operations" "numbers")
(check "Local definition 1" "local-def-1")
(check "Local definition 2" "local-def-2")
(check "Local definition 3" "local-def-3")
(check "Local definition 4" "local-def-4")
